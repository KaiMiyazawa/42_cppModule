# cpp Module 01

**製作者**: kmiyazawa

## 概要
このモジュールはC++のメモリ管理、ポインタ、参照について学習するためのプロジェクトです。動的メモリ割り当て、ポインタと参照の違い、ファイル操作などの重要な概念を実践的に学習します。

## 学習目標
- 動的メモリ割り当ての理解と実装
- ポインタと参照の違いとそれぞれの適切な使用場面
- スタックメモリとヒープメモリの理解
- ファイル入出力操作
- 関数ポインタの使用
- メモリリークの防止

## Exercise 00: BraiiiiiiinnnzzzZ

### 概要
Zombieクラスを使用して、ヒープとスタックでのオブジェクト作成の違いを学習します。

### 学習内容
- 動的メモリ割り当て（`new`/`delete`）
- スタックとヒープの違い  
- オブジェクトのライフサイクル管理
- クラスのコンストラクタとデストラクタ

### 使用されるC++機能
- `new`演算子と`delete`演算子
- クラス定義とメンバ関数
- コンストラクタ・デストラクタ
- ポインタによるメンバアクセス（`->`）

### コンパイル・実行方法
```bash
cd ex00
make
./zombie
```

### 重要なポイント
- `newZombie()`: ヒープにZombieオブジェクトを作成（手動でdeleteが必要）
- `randomChump()`: スタックにZombieオブジェクトを作成（自動的に破棄）
- メモリリークの防止
- 適切なスコープでのオブジェクト管理

## Exercise 01: Moar brainz!

### 概要
Zombieオブジェクトの配列を動的に作成し、配列のメモリ管理を学習します。

### 学習内容
- 動的配列の作成（`new[]`/`delete[]`）
- 配列の初期化とアクセス
- 複数オブジェクトのメモリ管理

### 使用されるC++機能
- `new[]`演算子と`delete[]`演算子
- 配列のポインタアクセス
- ループによる配列の初期化

### コンパイル・実行方法
```bash
cd ex01
make
./zombie
```

### 重要なポイント
- `zombieHorde()`: 指定された数のZombieオブジェクト配列を生成
- 配列全体に対する`delete[]`の使用
- 各Zombieオブジェクトに名前を設定
- メモリ効率を考慮した実装

## Exercise 02: HI THIS IS BRAIN

### 概要
ポインタと参照の基本的な使い方と違いを実践的に学習します。

### 学習内容
- ポインタと参照の宣言と使用
- メモリアドレスの表示
- ポインタと参照によるアクセス方法の違い

### 使用されるC++機能
- ポインタ（`*`）
- 参照（`&`）
- アドレス演算子
- ポインタと参照による値アクセス

### コンパイル・実行方法
```bash
cd ex02
make
./brain
```

### 重要なポイント
- 文字列のメモリアドレスの表示
- ポインタによるアクセス（`*stringPTR`）
- 参照によるアクセス（`stringREF`）
- ポインタと参照のアドレスが同じことの確認

## Exercise 03: Unnecessary violence

### 概要
HumanAとHumanBクラスを通じて、ポインタと参照のメンバ変数としての使用方法を学習します。

### 学習内容
- メンバ変数としてのポインタと参照
- オブジェクトの関連性の設定
- ポインタと参照の初期化タイミングの違い

### 使用されるC++機能
- クラスメンバとしてのポインタ・参照
- 初期化リスト
- オブジェクト間の関連付け

### コンパイル・実行方法
```bash
cd ex03
make
./violence
```

### 重要なポイント
- **HumanA**: 参照としてWeaponを保持（必ず武器を持つ）
- **HumanB**: ポインタとしてWeaponを保持（武器を持たない場合もある）
- 参照は初期化時に設定必須、ポインタは後から設定可能
- 適切な設計パターンの選択

## Exercise 04: Sed is for losers

### 概要
ファイルの読み書きと文字列置換を行うプログラムを実装し、ファイル操作を学習します。

### 学習内容
- ファイルストリームの使用
- 文字列の検索と置換
- エラーハンドリング
- コマンドライン引数の処理

### 使用されるC++機能
- `std::ifstream`と`std::ofstream`
- `std::string::find()`
- `std::string::replace()`
- ファイルの存在確認

### コンパイル・実行方法
```bash
cd ex04
make
./replace filename s1 s2
```

### 重要なポイント
- ファイルの読み込みと書き込み
- 文字列内の全ての対象文字列を置換
- エラーケースの適切な処理
- 出力ファイル名の生成（filename.replace）

## Exercise 05: Harl 2.0

### 概要
関数ポインタを使用してif-else文の連続を避ける効率的なプログラム構造を学習します。

### 学習内容
- 関数ポインタの使用方法
- 関数ポインタの配列
- 効率的な条件分岐の実装
- メンバ関数ポインタ

### 使用されるC++機能
- メンバ関数ポインタ
- 配列によるテーブル駆動設計
- 文字列比較とループ処理

### コンパイル・実行方法
```bash
cd ex05
make
./harl
```

### 重要なポイント
- 4つのログレベル（DEBUG, INFO, WARNING, ERROR）
- 関数ポインタ配列による効率的な実装
- if-elseの森を避けたクリーンなコード
- スケーラブルな設計パターン

## 全体の学習成果
このモジュールを通じて以下の重要な概念を習得しました：

### メモリ管理
- スタックとヒープの使い分け
- 動的メモリ割り当てと解放
- メモリリークの防止策

### ポインタと参照
- ポインタと参照の違い
- 適切な使用場面の判断
- メンバ変数としての活用

### ファイル操作
- ファイルストリームの使用
- エラーハンドリング
- 文字列処理

### 設計パターン
- 関数ポインタによるテーブル駆動設計
- オブジェクト指向の基本原則
- 効率的なコード構造

## 注意点
- **メモリ管理**: `new`で確保したメモリは必ず`delete`で解放
- **配列**: `new[]`で確保したメモリは`delete[]`で解放
- **参照**: 初期化時に必ず設定が必要
- **ポインタ**: NULL チェックを忘れずに実装
- **ファイル操作**: ファイルのオープン・クローズを確実に実行